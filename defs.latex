% This part is generated from `defs.toml` on codeforces.polygon. 

\NewDocumentCommand{\DefSubsequence}{O{a}O{b}}{A sequence $#1$ is a subsequence of a sequence $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) element from arbitrary positions.
}

\NewDocumentCommand{\DefSubsegment}{O{a}O{b}}{A sequence $#1$ is a subsegment of a sequence $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
}

\NewDocumentCommand{\DefSubarray}{O{a}O{b}}{An array $#1$ is a subarray of an array $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
}

\NewDocumentCommand{\DefSubstring}{O{a}O{b}}{A string $#1$ is a substring of a string $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.
}

\NewDocumentCommand{\DefSubsequenceInd}{O{a}O{b}}{A sequence $#1$ is a subsequence of a sequence $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) element from arbitrary positions.
Two subsequences are considered different if the sets of \textbf{positions} of the deleted elements are different.
}

\NewDocumentCommand{\DefSubsegmentInd}{O{a}O{b}}{A sequence $#1$ is a subsegment of a sequence $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
Two subsequences are considered different if the sets of \textbf{positions} of the deleted elements are different.
}

\NewDocumentCommand{\DefSubarrayInd}{O{a}O{b}}{An array $#1$ is a subarray of an array $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
Two subarrays are considered different if the sets of \textbf{positions} of the deleted elements are different.
}

\NewDocumentCommand{\DefSubstringInd}{O{a}O{b}}{A string $#1$ is a substring of a string $#2$ if $#1$ can be obtained from $#2$ by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.
Two substrings are considered different if the sets of \textbf{positions} of the deleted elements are different.
}

\NewDocumentCommand{\DefPermutation}{O{n}}{A permutation of length $#1$ is an array consisting of $#1$ distinct integers from $1$ to $#1$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($#1=3$ but there is $4$ in the array).
}

\NewDocumentCommand{\DefLexMinStr}{O{a}O{b}}{A string $#1$ is lexicographically smaller than string $#2$ if and only if one of the following holds:
\begin{itemize}
\item $#1$ is a prefix of $#2$, but $#1 \ne #2$; or
\item in the first position where $#1$ and $#2$ differ, the string $#1$ has a letter that appears earlier in the alphabet than the corresponding letter in $#2$.
\end{itemize}
}

\NewDocumentCommand{\DefLexMinSeq}{O{a}O{b}}{A sequence $#1$ is lexicographically smaller than a sequence $#2$ if and only if one of the following holds:
\begin{itemize}
\item $#1$ is a prefix of $#2$, but $#1 \ne #2$; or
\item in the first position where $#1$ and $#2$ differ, the sequence $#1$ has a smaller element than the corresponding element in $#2$.
\end{itemize}
}

\NewDocumentCommand{\DefLexMinArr}{O{a}O{b}}{An array $#1$ is lexicographically smaller than an array $#2$ if and only if one of the following holds:
\begin{itemize}
\item $#1$ is a prefix of $#2$, but $#1 \ne #2$; or
\item in the first position where $#1$ and $#2$ differ, the array $#1$ has a smaller element than the corresponding element in $#2$.
\end{itemize}
}

\NewDocumentCommand{\DefLexMinStrEqsz}{O{a}O{b}}{A string $#1$ is lexicographically smaller than a string $#2$ of the same length, if and only if the following holds:
\begin{itemize}
\item $#1 \ne #2$, and in the first position where $#1$ and $#2$ differ, the string $#1$ has a letter that appears earlier in the alphabet than the corresponding letter in $#2$.
\end{itemize}
}

\NewDocumentCommand{\DefLexMinSeqEqsz}{O{a}O{b}}{A sequence $#1$ is lexicographically smaller than a sequence $#2$ of the same length if and only if the following holds:
\begin{itemize}
\item $#1 \ne #2$, and in the first position where $#1$ and $#2$ differ, the sequence $#1$ has a smaller element than the corresponding element in $#2$.
\end{itemize}
}

\NewDocumentCommand{\DefLexMinArrEqsz}{O{a}O{b}}{An array $#1$ is lexicographically smaller than an array $#2$ of the same size if and only if the following holds:
\begin{itemize}
\item $#1 \ne #2$, and in the first position where $#1$ and $#2$ differ, the array $#1$ has a smaller element than the corresponding element in $#2$.
\end{itemize}
}

\NewDocumentCommand{\DefBitwiseXOR}{O{\oplus}O{https://en.wikipedia.org/wiki/Bitwise_operation#XOR}}{$#1$ denotes the \href{#2}{bitwise XOR operation}.
}

\NewDocumentCommand{\DefBitwiseOR}{O{|}O{https://en.wikipedia.org/wiki/Bitwise_operation#OR}}{$#1$ denotes the \href{#2}{bitwise OR operation}.
}

\NewDocumentCommand{\DefBitwiseAND}{O{\&}O{https://en.wikipedia.org/wiki/Bitwise_operation#AND}}{$#1$ denotes the \href{#2}{bitwise AND operation}.
}

\NewDocumentCommand{\DefGCD}{O{x}O{y}}{$\gcd(#1, #2)$ denotes the \href{https://en.wikipedia.org/wiki/Greatest_common_divisor}{greatest common divisor (GCD)} of integers $#1$ and $#2$.
}

\NewDocumentCommand{\DefLCM}{O{x}O{y}}{$\operatorname{lcm}(#1, #2)$ denotes the \href{https://en.wikipedia.org/wiki/Least_common_multiple}{lowest common divisor (LCM)} of integers $#1$ and $#2$.
}

\NewDocumentCommand{\DefMEX}{O{c}O{k}O{x}}{$\operatorname{mex}(#1)$ denotes the minimmum excluded (MEX)\footnote{\DefMEXfull[#1][#2][#3]} of the collection $#1$.
}

\NewDocumentCommand{\DefMEXfull}{O{c}O{k}O{x}}{The minimum excluded (MEX) of a collection of integers $#1_1, #1_2, \ldots, #1_#2$ is defined as
the smallest non-negative integer $#3$ which does not occur in the collection $#1$.
}

\NewDocumentCommand{\DefMOD}{O{x}O{y}}{$#1 \bmod #2$ denotes the remainder from dividing $#1$ by $#2$.
}

\NewDocumentCommand{\DefTestcases}{O{t}O{10^4}}{Each test contains multiple test cases.
The first line contains the number of test cases $#1$ ($1 \le #1 \le #2$).
The description of the test cases follows.
}

\NewDocumentCommand{\DefLimitSum}{O{n}O{10^5}}{It is guaranteed that the sum of $#1$ over all test cases does not exceed $#2$.
}

\NewDocumentCommand{\DefSubtask}{O{easy}O{???}}{\textbf{This is the #1 version of the problem. The difference between the versions is that in this version, #2. You can hack only if you solved all versions of this problem.}
}

\NewDocumentCommand{\DefInteractive}{}{\textit{This is an interactive problem.}
}

\NewDocumentCommand{\DefFlush}{O{$-1$}}{After printing each query do not forget to output the end of line and flush\footnote{To
flush, use:
\begin{itemize}
\item \t{fflush(stdout)} or \t{cout.flush()} in C++;
\item \t{sys.stdout.flush()} in Python;
\item see the documentation for
other languages.
\end{itemize}} the output. Otherwise, you will get
\t{Idleness limit exceeded} verdict.
 
If, at any interaction step, you read #1 instead of valid data, your solution must exit immediately.
This means that your solution will receive \t{Wrong answer} because of an invalid query or any other mistake.
Failing to exit can result in an arbitrary verdict because your solution will continue to read from a closed stream.
}

\NewDocumentCommand{\DefPrecision}{O{10^{-9}}O{a}O{b}}{Your answer is considered correct if its absolute or relative error does not exceed $#1$.
 
Formally, let your answer be $#2$, and the jury's answer be $#3$.
Your answer is accepted if and only if $\frac{|#2 - #3|}{\max{(1, |#3|)}} \le #1$.
}

\NewDocumentCommand{\DefModuloFracAnswer}{O{998\,244\,353}O{M}O{p}O{q}O{x}}{Formally, let $#2 = #1$.
It can be shown that the exact answer can be expressed as an irreducible fraction $\frac{#3}{#4}$,
where $#3$ and $#4$ are integers and $#4 \not \equiv 0 \pmod{#2}$.
Output the integer equal to $#3 \cdot #4^{-1} \bmod #2$.
In other words, output such an integer $#5$ that $0 \le x < #2$ and $#5 \cdot #4 \equiv #3 \pmod{#2}$.
}

\NewDocumentCommand{\DefTree}{}{A tree is a connected graph without cycles.
}

\NewDocumentCommand{\DefRootedTree}{}{A rooted tree is a tree where one vertex is special and called the root.
}

\NewDocumentCommand{\DefParent}{O{v}}{The parent of vertex $#1$ is the first vertex on the simple path from $#1$ to the root. The root has no parent.
}

\NewDocumentCommand{\DefAncestor}{O{v}}{An ancestor of vertex $#1$ is any vertex on the simple path from $#1$ to the root, including the root, but not including $#1$. The root has no ancestors.
}

\NewDocumentCommand{\DefChild}{O{v}O{u}}{A child of vertex $#1$ is any vertex $#2$ for which $#1$ is the parent.
}

\NewDocumentCommand{\DefTreeLeaf}{}{A leaf is any vertex without children.
}

\NewDocumentCommand{\DefDescendant}{O{v}O{u}}{A descendant of vertex $#1$ is any vertex $#2$ for which $#1$ is an ancestor. No vertex is its own descendant.
}

\NewDocumentCommand{\DefSubtree}{O{v}}{A subtree of vertex $#1$ is the subgraph of $#1$, all its descendants, and all the edges between them.
}

\NewDocumentCommand{\DefBinaryTree}{}{A binary tree is rooted tree, in which each node has no more than $2$ children.
}

\NewDocumentCommand{\DefFullBinaryTree}{}{A full binary tree is rooted tree, in which each node has $0$ or $2$ children.
}

\NewDocumentCommand{\DefYesNoCaseInsensitive}{}{You can output the answer in any case (upper or lower). For example, the strings ``\t{yEs}'', ``\t{yes}'', ``\t{Yes}'', and ``\t{YES}'' will be recognized as positive responses.
}

\NewDocumentCommand{\DefYesNoFull}{O{the answer exists}}{For each test case, output ``\t{YES}'' if #1, and ``\t{NO}'' otherwise.
 
You can output the answer in any case (upper or lower). For example, the strings ``\t{yEs}'', ``\t{yes}'', ``\t{Yes}'', and ``\t{YES}'' will be recognized as positive responses.
}

\NewDocumentCommand{\DefFloor}{O{x}}{$\lfloor #1\rfloor$ denotes the \href{https://en.wikipedia.org/wiki/Floor_and_ceiling_functions}{floor} of $#1$, which is the greatest integer less than or equal to $#1$.
}

\NewDocumentCommand{\DefCeil}{O{x}}{$\lceil #1\rceil$ denotes the \href{https://en.wikipedia.org/wiki/Floor_and_ceiling_functions}{ceiling} of $#1$, which is the smallest integer greater than or equal to $#1$.
}

\NewDocumentCommand{\DefSubarrayLR}{O{a}O{l}O{r}}{The subarray $#1_{#2 \ldots #3}$ refers to the contiguous segment of the array $#1$ that starts at index $#2$ and ends at index $#3$, i.e., $[#1_#2, #1_{#2+1}, \ldots, #1_#3]$.
}

\NewDocumentCommand{\DefNoLimitSum}{O{n}}{Note that there are no constraints on the sum of $#1$ over all test cases.
}

\NewDocumentCommand{\DefTriangleNumber}{O{}}{\frac{#1\cdot(#1-1)}{2}
}

